import tkinter as tk
from tkinter import *
from tkinter import ttk, filedialog
from TAB import MULTITABS
from pandas import DataFrame
import re
import pandas as pd
import os
from collections import defaultdict
import shutil
from filecmp import *
from datetime import date
from tkinter.ttk import Progressbar
import codecs
import xlrd
# creating tkinter window


class MainWindow():
   def __init__(self, master):
      self.master = master
      master.title("A simple GUI")
      master.geometry('1020x520')
      self.setup_ui(self.master)

   def setup_ui(self,master):
      self.create_widgets(master)
      self.modify_widgets(master)
      self.create_layouts()
      self.add_widgets_to_layouts(master)
      self.setup_connections('current','FALSE')

   def bar(self,window, progress,val):
      import time
      progress['value'] = val
      window.update_idletasks()
      time.sleep(1)

   def DeleteCurrentEntry(self, treeView):
      curr = treeView.focus()

      if '' == curr: return

      treeView.delete(curr)

   def ConfirmEntry(self, treeView, entries):
      ####
      # Whatever validation you need
      ####
      # Grab the current index in the tree
      currInd = treeView.index(treeView.focus())

      text_L = self.treev_2.item(treeView.focus())['text']
      # Remove it from the tree
      self.DeleteCurrentEntry(treeView)
      entries_values = ()
      for val in entries:
         entries_values += (val.get(),)

      # Put it back in with the upated values
      treeView.insert('', currInd, values=entries_values,text=text_L)


      file = 'Dictionary\\DICTIONARY'
      #num = treeView.item(treeView.focus())['values'][0]
      with open(file, "r+") as f:
         d = f.readlines()
         f.seek(0)
         for i in d:
            if not re.match('DICT' + self.regle_tree  + str(currInd),i):
               f.write(i)
         f.truncate()

      with codecs.open(file, "a", "utf-8") as filout:
           filout.write('DICT'+ self.regle_tree  + str(currInd) + "                   " + entries_values[1] + "\n")
      return True



   def editLine(self, treeView):

      # First check if a blank space was selected
      entryIndex = treeView.focus()
      if '' == entryIndex: return

      # Set up window
      win = Toplevel()
      win.title("Edit Entry")
      win.attributes("-toolwindow", True)

      ####
      # Set up the window's other attributes and geometry
      ####

      # Grab the entry's values
      for child in treeView.get_children():
         if child == entryIndex:
            values = treeView.item(child)["values"]
            break

      entries = []
      i = 0
      j= 0
      for val in values :
         col1Lbl = Label(win, text="Value : " + str(i + 1))
         col1Ent = Entry(win)
         col1Ent.insert(i, val)  # Default is column 1's current value
         col1Lbl.grid(row=0, column=j)
         col1Ent.grid(row=0, column=j+1)
         entries.append(col1Ent)
         i = i + 1
         j = j + 2

      """col2Lbl = Label(win, text="Value 2: ")
      col2Ent = Entry(win)
      col2Ent.insert(0, values[1])  # Default is column 2's current value
      col2Lbl.grid(row=0, column=2)
      col2Ent.grid(row=0, column=3)

      col3Lbl = Label(win, text="Value 3: ")
      col3Ent = Entry(win)
      col3Ent.insert(0, values[2])  # Default is column 3's current value
      col3Lbl.grid(row=0, column=4)
      col3Ent.grid(row=0, column=5)"""

      def UpdateThenDestroy():
         if self.ConfirmEntry(treeView, entries):
            win.destroy()

      okButt = Button(win, text="Ok")
      okButt.bind("<Button-1>", lambda e: UpdateThenDestroy())
      okButt.grid(row=1, column=4)

      canButt = Button(win, text="Cancel")
      canButt.bind("<Button-1>", lambda c: win.destroy())
      canButt.grid(row=1, column=5)

   def loadFile(self):
      curItem = self.treev_versions.focus()
      mois = self.treev_versions.item(curItem)['values'][0]
      version = self.treev_versions.item(curItem)['values'][1]

      self.progress.pack(side=BOTTOM)

      self.bar(self.master,self.progress,20)

      self.setup_connections('RDJ\\' + mois + '\\' + version,'TRUE')

      self.label_config['text'] = 'La version RDJ disponible est de la date : ' + version

      for f in os.listdir('current') :
         os.remove('current\\' + f)

      shutil.copy('RDJ\\' + mois + '\\' + version, 'current\\' + version)

   def getFile(self):
      self.tree_p.delete(*self.tree_p.get_children())
      self.Regle = self.tree_p.insert("", 'end', text="Règles de Traduction")
      self.Champ = self.tree_p.insert("", 'end', text="Champ")
      self.Variable = self.tree_p.insert("", 'end', text="Variable")
      self.Table = self.tree_p.insert("", 'end', text="Table")
      self.import_file_path = filedialog.askopenfilename()
      self.setup_connections(self.import_file_path,'FALSE')

   def saveFile(self):
      today = date.today()
      month = today.strftime("%B")
      d = today.strftime("%d%m%Y")
      if not os.path.exists('RDJ\\'+month):
         os.makedirs('RDJ\\'+month)

      extension = self.import_file_path.split('.')[1]
      shutil.copy(self.import_file_path, 'RDJ\\'+month+ '\\Version_' + d + '.' + extension)

      self.treev_versions.delete(*self.treev_versions.get_children())
      for dir in os.listdir('RDJ') :
         mois = self.treev_versions.insert("", 'end', text=dir)
         for f in os.listdir('RDJ\\'+ dir):
            self.treev_versions.insert(mois, "end", text=f, values=(dir,f))

      for f in os.listdir('current') :
         os.remove('current\\' + f)

      shutil.copy('RDJ\\' + month + '\\Version_' + d + '.' + extension,'current\Version_' + d + '.' + extension )

   def popup(self, e):
       curItem = self.treev_2.focus()
       if (self.treev_2.item(curItem)['text'] == ''):
           print("No item selected")
           self.popup_menu = tk.Menu(self.master, tearoff=0)

           #self.popup_menu.add_command(label="BringDictionary", command=lambda: self.editLine(self.treev_2))
           #self.popup_menu.add_command(label="ResetDictionary", command=lambda: self.editLine(self.treev_2))
           self.popup_menu.add_command(label="BringDictionary", command=self.bringDict)
           self.popup_menu.add_command(label="ResetDictionary", command=self.resetDict)

           try:
               self.popup_menu.tk_popup(e.x_root, e.y_root)
           finally:
               self.popup_menu.grab_release()
       else:
           self.popup_menu = tk.Menu(self.master, tearoff=0)

           self.popup_menu.add_command(label="EditLine", command=lambda: self.editLine(self.treev_2))
           self.popup_menu.add_separator()
           self.popup_menu.add_command(label="BringDictionary", command=self.bringDict)
           self.popup_menu.add_command(label="ResetDictionary", command=self.resetDict)

           try:
               self.popup_menu.tk_popup(e.x_root, e.y_root)
           finally:
               self.popup_menu.grab_release()

   def bringDict(self):

      self.dict_line_dictionary = {}

      with open("Dictionary\\DICTIONARY",encoding='utf-8') as f:
         for line in f:
            if re.match('DICT'+self.regle_tree, line):
               if re.split('DICT', line)[1][:5].strip() in self.dict_line_dictionary.keys():
                  self.dict_line_dictionary[re.split('DICT', line)[1][:5].strip()] = self.dict_line_dictionary[re.split('DICT', line)[1][:5].strip()] + '|' + line.rstrip('\n')
               else:
                  self.dict_line_dictionary[re.split('DICT', line)[1][:5].strip()] = line.rstrip('\n')
      self.onselect("DICTIONARY")

   def resetDict(self):
      self.dict_line_dictionary = {}
      self.onselect("")

   def show_hide_tab(self,hidden,ctx):
         if hidden == 2 :
            self.tabControl.add(self.tab2, text='Pré-calcul')
            self.tabControl.add(self.tab3, text='Schémas')
         if hidden == 1:
            self.tabControl.add(self.tab2, text='Pré-calcul')
            self.tabControl.hide(self.tab3)
         if hidden == 0 :
               self.tabControl.hide(self.tab2)
               self.tabControl.hide(self.tab3)

   def save_Champ(self,evt):
      file = 'Dictionary\\DICTIONARY'
      # num = treeView.item(treeView.focus())['values'][0]
      libellé_champ = self.text3.get("1.0", END)
      ctx=self.label_tag
      with open(file, "r+") as f:
         d = f.readlines()
         f.seek(0)
         for i in d:
            if not re.match(ctx + self.regle_tree , i):
               f.write(i)
         f.truncate()

      with codecs.open(file, "a", "utf-8") as filout:
         filout.write(ctx + self.regle_tree + "                   " + libellé_champ + "\n")
      return True


   def create_widgets(self,master):

   #Menu-----------------------------------------------------
      self.menubar = Menu(master)
      self.filemenu = Menu(self.menubar, tearoff=0)
      self.helpmenu = Menu(self.menubar, tearoff=0)

      #TabControle
      self.tabControl_p = ttk.Notebook(master)

      #Tabs
      self.tab0_p = ttk.Frame(self.tabControl_p)
      self.tab1_p = ttk.Frame(self.tabControl_p)
      self.tab2_p = ttk.Frame(self.tabControl_p)

      #ConfigTab



      self.frameConfig = Frame(self.tab0_p)
      self.frame_btns = Frame(self.frameConfig,bg = '#cacccc',height=300)
      self.frame_progressBar = Frame(self.frameConfig, bg='#cacccc', height=300)
      self.label_config = Label(self.frameConfig, text="La version RDJ disponible est de la date :")

      self.browseButton_Config_0 = ttk.Button(self.frame_btns, text='Load', command=self.loadFile, style='Fun.TButton')

      self.browseButton_Config = ttk.Button(self.frame_btns, text='Import', command=self.getFile, style='Fun.TButton')
      self.browseButton_Config_2 = ttk.Button(self.frame_btns, text='Save', command=self.saveFile, style='Fun.TButton')
      self.treev_versions = ttk.Treeview(self.frameConfig, selectmode='browse')
      self.scrollbar_versions = Scrollbar(self.frameConfig, orient="vertical")

      self.progress = Progressbar(self.frame_progressBar, orient=HORIZONTAL,length=100, mode='determinate')

      #RDJ-----------
      self.frame = Frame(self.tab1_p,bg = '#cacccc')

      self.tree_p = ttk.Treeview(self.frame, selectmode='browse')
      self.scrollbar = Scrollbar(self.frame, orient="vertical")

      #TABS
      self.frameTab = Frame(self.tab1_p,bg = '#cacccc')
      self.tabControl = ttk.Notebook(self.frameTab,width=2000)

      self.tab1 = ttk.Frame(self.tabControl, height=110, width=2000)
      self.tab2 = ttk.Frame(self.tabControl, height=110, width=2000)
      self.tab3 = ttk.Frame(self.tabControl, height=110, width=2000)

      #self.frame_dict = Frame(self.tab1_p,bg = '#cacccc')
      #self.bring_dict_btn = ttk.Button(self.frame_dict, text='Bring Dictionary', command=self.bringDict, style='Fun.TButton')
      #self.reset_dict_btn = ttk.Button(self.frame_dict, text='Reset Dictionary', command=self.resetDict, style='Fun.TButton')


      self.treev = ttk.Treeview(self.tab2, selectmode='browse')
      self.vsb = ttk.Scrollbar(self.tab2, orient="vertical")


      self.treev_2 = ttk.Treeview(self.tab3, selectmode='browse')
      self.vsb_2 = ttk.Scrollbar(self.tab3, orient="vertical", command=self.treev.yview)

      #TAB1 Frame
      self.frameTab1 = Frame(self.tab1)
      self.frameText1_2 = Frame(self.tab1,highlightbackground="black")
      self.frameText3 = Frame(self.tab1,highlightbackground="black")
      self.frameText4 = Frame(self.tab1, highlightbackground="black")
      self.frameText5 = Frame(self.tab1, highlightbackground="black")

      self.label1 = Label(self.frameText1_2, text="Nom :")
      self.label1.grid(row=1,pady=(15,0),padx=(50,0))
      self.text1 = Text(self.frameText1_2, width=30, height=1.2)
      self.text1.grid(row=1,column=1,pady=(20,0),padx=(25,0))

      self.label2 = Label(self.frameText1_2, text="Version :")
      self.label2.grid(row=1,column=2, pady=(15, 0), padx=(50, 0))
      self.text2 = Text(self.frameText1_2, width=30, height=1.2)
      self.text2.grid(row=1, column=3, pady=(20, 0),padx=(25, 0))

      self.label3 = Label(self.frameText3, text="Libellé :")
      self.label3.grid(row=2)
      self.text3 = Text(self.frameText3, width=60, height=1.2)
      self.text3.grid(row=2, column=1, pady=(20, 0),padx=(25, 0))

      self.label4 = Label(self.frameText4, text="Statut :")
      self.label4.grid(row=3)
      self.text4 = Text(self.frameText4, width=30, height=1.2)
      self.text4.grid(row=3, column=1, pady=(20, 0),padx=(25, 0))

      self.label5 = Label(self.frameText5, text="Date de début :")
      self.label5.grid(row=4)
      self.text5 = Text(self.frameText5, width=30, height=1.2)
      self.text5.grid(row=4, column=1, pady=(20, 0),padx=(25, 0))

      self.label6 = Label(self.frameText5, text="Date de fin :")
      self.label6.grid(row=4,column=3)
      self.text6 = Text(self.frameText5, width=30, height=1.2)
      self.text6.grid(row=4, column=4, pady=(20, 0), padx=(25, 0))

      # ----Actions-----
      self.tree_p.bind("<<TreeviewSelect>>", self.onselect)
      self.treev_2.bind("<Double-1>", self.show)
      self.treev_2.bind("<Button-3>", self.popup)

      self.text3.bind("<FocusOut>", self.save_Champ)

   def modify_widgets(self,master):
      #------Menu-------
      self.filemenu.add_command(label="New")
      self.filemenu.add_command(label="Open")
      self.filemenu.add_command(label="Save")
      self.filemenu.add_separator()
      self.filemenu.add_command(label="Exit", command=master.quit)
      self.menubar.add_cascade(label="File", menu=self.filemenu)
      self.helpmenu.add_command(label="Help Index", )
      self.helpmenu.add_command(label="About...", )
      self.menubar.add_cascade(label="Help", menu=self.helpmenu)

      #RDJ Update
      self.frameTab1.grid()
      self.frameText1_2.grid()
      self.frameText3.grid(ipadx=45)
      self.frameText4.grid(ipadx=165)
      self.frameText5.grid(ipadx=15)


      #-----tree_p-----

      self.tree_p.column("#0", width=180, minwidth=270, stretch=tk.NO)

      self.tree_p.heading("#0", text="Section",anchor='c')

      # Level 1
      self.Regle = self.tree_p.insert("", 'end', text="Règles de Traduction")
      self.Champ = self.tree_p.insert("", 'end', text="Champ")
      self.Variable = self.tree_p.insert("", 'end', text="Variable")
      self.Table = self.tree_p.insert("", 'end', text="Table")
      #-----treev------------

      self.treev["columns"] = ("1", "2")
      self.treev['show'] = 'headings'

      self.treev.column("1", anchor='c')
      self.treev.column("2", anchor=tk.W)

      self.treev.heading("1", text="Nom")
      self.treev.heading("2", text="Expression de garnissage")

      #------treev_versions
      self.treev_versions.column("#0", width=300)

      self.treev_versions.heading("#0", text="Section", anchor='c')

      # Level 1
      #self.mois = self.treev_versions.insert("", 'end', text="Août")
      #self.Tables = self.tree_p.insert("", 'end', text="Septembre")

      for d in os.listdir('RDJ') :
         mois = self.treev_versions.insert("", 'end', text=d)
         for f in os.listdir('RDJ\\'+ d):
            self.treev_versions.insert(mois, "end", text=f, values=(d,f))

      # -----treev_2------------

      self.treev_2["columns"] = ("1", "2","3","4")
      self.treev_2['show'] = 'headings'
      self.treev_2["displaycolumns"] = ("1","2", "3")

      self.treev_2.column("1", anchor='c')
      self.treev_2.column("2", anchor='c')
      self.treev_2.column("3", anchor=tk.W)

      self.treev_2.heading("1", text="Nom")
      self.treev_2.heading("2", text="Libellé")
      self.treev_2.heading("3", text="Condition")
      self.treev_2.heading("4", text="schm")

      #TAB1 Frame
      #self.frameTab1.pack()

   def create_layouts(self) :
      #ALL
      self.tabControl_p.add(self.tab0_p, text='Config')
      self.tabControl_p.add(self.tab1_p, text='RDJ')
      self.tabControl_p.add(self.tab2_p, text='Compute')

      #RDJ
      self.tabControl.add(self.tab1, text='Général')

      self.tabControl.add(self.tab2, text='Pré-calcul')
      self.tabControl.add(self.tab3, text='Schémas')



   def add_widgets_to_layouts(self,master) :
      master.config(menu=self.menubar)
      self.tabControl_p.pack(expand=1, fill="both")
      self.tabControl.pack(side=LEFT, fill="both")
      #self.frame_dict.pack(side=TOP,pady=20)

      #Config
      self.label_config.pack(side=TOP,pady=20)
      self.browseButton_Config_0.pack(side=LEFT)
      self.browseButton_Config.pack(side=LEFT)
      self.browseButton_Config_2.pack(side=LEFT)
      self.progress.pack(side=BOTTOM)
      #self.bring_dict_btn.pack(side=LEFT)
      #self.reset_dict_btn.pack(side=RIGHT)

      #----Frames------
         # Config
      self.frameConfig.pack(pady=90,ipadx=100)
      self.frame_btns.pack(side=BOTTOM,pady=20)
      self.frame_progressBar.pack(side=BOTTOM, pady=20)
         # RDJ
      self.frame.pack(side=LEFT, ipady=80, padx=40)
            # FramTab
      self.frameTab.pack(side=LEFT, ipady=40, padx=40)

      # -----ScrollBar--------
      self.scrollbar_versions.config(command=self.treev_versions.yview)
      self.scrollbar_versions.pack(side='right', fill=BOTH)

      self.scrollbar.config(command=self.tree_p.yview)
      self.scrollbar.pack(side='right', fill=BOTH)

      self.vsb.config(command=self.treev.yview)
      self.vsb.pack(side='right', fill='y')

      self.vsb_2.config(command=self.treev_2.yview)
      self.vsb_2.pack(side='right', fill='y')

      #------Trees-------
      self.treev.pack(fill='both', expand=TRUE)
      self.treev.configure(yscrollcommand=self.vsb.set)

      self.treev_2.pack(fill='both', expand=TRUE)
      self.treev_2.configure(yscrollcommand=self.vsb_2.set)

      self.tree_p.pack(fill='both', expand=TRUE)
      self.tree_p.configure(yscrollcommand=self.scrollbar.set)

      self.treev_versions.pack(side=LEFT,expand=TRUE,fill=BOTH)
      self.treev_versions.configure(yscrollcommand=self.scrollbar_versions.set)

   def setup_connections(self,file,onLoad):

      self.bar(self.master, self.progress, 40)

      if file == 'current' :
         for f in os.listdir('current') :
            file = 'current\\' + f
            self.label_config['text'] = 'La version RDJ disponible est de la date : ' + f.split('.txt')[0]


      if onLoad == 'TRUE' :
         self.tree_p.delete(*self.tree_p.get_children())
         self.Regle = self.tree_p.insert("", 'end', text="Règles de Traduction")
         self.Champ = self.tree_p.insert("", 'end', text="Champ")
         self.Variable = self.tree_p.insert("", 'end', text="Variable")
         self.Table = self.tree_p.insert("", 'end', text="Table")

      #print(cmp('RDJ\\Version_.txt','RDJ\\Version_12.txt'))
      with open(file) as f:
            self.ser_OTE = pd.Series([])
            self.Liste_line = []
            self.dict_line_all = {}
            self.dict_line_champ = {}
            self.dict_line_variable = {}
            self.dict_line_table = {}
            self.dict_line_table_2 = defaultdict(dict)
            for line in f:
               self.Liste_line.append(line)
               if re.match('REE',line) :
                  if re.split('REE', line)[1][:5].strip() in self.dict_line_all.keys() :
                     self.dict_line_all[re.split('REE', line)[1][:5].strip()] = self.dict_line_all[re.split('REE', line)[1][:5].strip()] + '|' + line.rstrip('\n')
                  else :
                     self.dict_line_all[re.split('REE', line)[1][:5].strip()] = line.rstrip('\n')

               if re.match('RSC',line) :
                  if re.split('RSC', line)[1][:5].strip() in self.dict_line_all.keys() :
                     self.dict_line_all[re.split('RSC', line)[1][:5].strip()] = self.dict_line_all[re.split('RSC', line)[1][:5].strip()] + '|' + line.rstrip('\n')
                  else :
                     self.dict_line_all[re.split('RSC', line)[1][:5].strip()] = line.rstrip('\n')

               if re.match('RIN',line) :
                  if re.split('RIN', line)[1][:5].strip() in self.dict_line_all.keys() :
                     self.dict_line_all[re.split('RIN', line)[1][:5].strip()] = self.dict_line_all[re.split('RIN', line)[1][:5].strip()] + '|' + line.rstrip('\n')
                  else :
                     self.dict_line_all[re.split('RIN', line)[1][:5].strip()] = line.rstrip('\n')

               if re.match('RCR',line) :
                  fields = re.split(r'\s{2,}', line)
                  if fields[1] not in self.dict_line_champ.keys() :
                     self.dict_line_champ[fields[1]] = fields[1]

               if re.match('VRB',line) :
                  fields = re.split(r'\s{2,}', line)
                  var = fields[0].split('VRB')[1]
                  if var not in self.dict_line_variable.keys() :
                     self.dict_line_variable[var] = var

               if re.match('TAB',line) :
                  fields = re.split(r'\s{2,}', line)
                  var = fields[0].split('TAB')[1]
                  if fields[1].strip() == '0' and var not in self.dict_line_table.keys()  :
                     regle = var
                     self.dict_line_table[var] = var
                  elif fields[1].strip() != '0' or fields[1].strip() != '1':
                     chmp = str(fields[0].split(regle)[1])

                     if regle in self.dict_line_table_2.keys() :
                        if chmp in self.dict_line_table_2[regle].keys():
                           self.dict_line_table_2[regle][chmp] = self.dict_line_table_2[regle][chmp] + '|' + line.rstrip('\n')
                        else:
                           self.dict_line_table_2[regle][chmp] = line.rstrip('\n')
                     else :
                        self.dict_line_table_2[regle][chmp] = line.rstrip('\n')

               if re.match('TBL',line) :
                  fields = re.split(r'\s{2,}', line)
                  var = fields[0].split('TBL')[1]
                  if fields[1].strip() == '0' and var not in self.dict_line_table.keys():
                     regle = var
                     self.dict_line_table[var] = var

                  elif fields[1].strip() != '0' or fields[1].strip() != '1':
                     chmp = str(fields[0].split(regle)[1])

                     if regle in self.dict_line_table_2.keys() :
                        if chmp in self.dict_line_table_2[regle].keys():
                           self.dict_line_table_2[regle][chmp] = self.dict_line_table_2[regle][chmp] + '|' + line.rstrip('\n')
                        else:
                           self.dict_line_table_2[regle][chmp] = line.rstrip('\n')
                     else :
                        self.dict_line_table_2[regle][chmp] = line.rstrip('\n')

            self.bar(self.master, self.progress, 60)

            for key in self.dict_line_all.keys():
               ###self.mylist.insert(END, key)
               ###self.mylist.itemconfig("end", selectbackground='black')
               self.tree_p.insert(self.Regle, "end", text=key,values=(key))

            for key in self.dict_line_champ.keys():
               ###self.mylist.insert(END, key)
               ###self.mylist.itemconfig("end", selectbackground='black')
               self.tree_p.insert(self.Champ, "end", text=key, values=(key))

            self.bar(self.master, self.progress, 80)

            for key in self.dict_line_variable.keys():
               ###self.mylist.insert(END, key)
               ###self.mylist.itemconfig("end", selectbackground='black')
               self.tree_p.insert(self.Variable, "end", text=key, values=(key))

            for key in self.dict_line_table_2.keys():
               ###self.mylist.insert(END, key)
               ###self.mylist.itemconfig("end", selectbackground='black')
               self.tree_p.insert(self.Table, "end", text=key, values=(key))

            self.bar(self.master, self.progress, 100)

      #if self.progress is not None:
       #  self.bar(self.master, self.progress, 60)

   def bring_it(self,ctx):

      if ctx == "TABLE":
         self.show_hide_tab(1, ctx)
         self.text1.config(state='normal')
         self.text1.delete("1.0", tk.END)
         self.text1.insert(tk.END, self.regle_tree)
         self.text1.config(state='disabled')

         self.label2.grid_forget()
         self.text2.grid_forget()

         self.text3.config(state='normal')
         self.text3.delete("1.0", tk.END)

         self.treev.delete(*self.treev.get_children())



         for key,val in self.dict_line_table_2[self.regle_tree].items(): #.split('|'):
            #fields = re.split(r'\s{2,}', line)
            #compte=fields[0].split(self.regle_tree)[1]
            if key != "" :
               compte = re.split('P1O|!', val)[1]
               #val = fields[1].split('P1O')[1].split('!')[0]
               #lib = fields[1].split('P1O')[1].split('!')[0]
               self.treev.insert("", 'end', text="L2", values=(key, compte))

         with open("Dictionary\\DICTIONARY", encoding='utf-8') as f:
            for line in f:
               if re.match(ctx + self.regle_tree, line):
                  fields = re.split(r'\s{2,}', line)
                  self.text3.config(state='normal')
                  self.text3.delete("1.0", tk.END)
                  self.text3.insert(tk.END, fields[1])
                  self.text3.config(state='normal')
      else:
         self.show_hide_tab(0, ctx)
         self.text1.config(state='normal')
         self.text1.delete("1.0", tk.END)
         self.text1.insert(tk.END, self.regle_tree)
         self.text1.config(state='disabled')

         self.label2.grid_forget()
         self.text2.grid_forget()
         self.text3.delete("1.0", tk.END)
         with open("Dictionary\\DICTIONARY", encoding='utf-8') as f:
            for line in f:
               if re.match(ctx + self.regle_tree, line):
                  fields = re.split(r'\s{2,}', line)
                  self.text3.config(state='normal')
                  self.text3.delete("1.0", tk.END)
                  self.text3.insert(tk.END, fields[1])
                  self.text3.config(state='normal')

   def onselect(self, evt):
      ###regle =  str((self.mylist.get(ANCHOR)))
      curItem = self.tree_p.focus()

      self.regle_tree = self.tree_p.item(curItem)['values'][0]

      if self.regle_tree in self.dict_line_champ.keys() and self.regle_tree not in self.dict_line_all.keys() :
         self.label_tag = "CHAMP"
         self.bring_it("CHAMP")

      elif self.regle_tree in self.dict_line_variable.keys() and self.regle_tree not in self.dict_line_all.keys() :
         self.label_tag = "VARIABLE"
         self.bring_it("VARIABLE")

      elif self.regle_tree in self.dict_line_table_2.keys() and self.regle_tree not in self.dict_line_all.keys() :
         self.label_tag = "TABLE"
         self.bring_it("TABLE")
      else :
         self.show_hide_tab(2,"")

         self.treev.delete(*self.treev.get_children())
         self.treev_2.delete(*self.treev_2.get_children())

         self.dict_data_var = {}
         self.dict_data_reg = defaultdict(dict)
         self.dict_data_cdt = defaultdict(dict)
         self.dict_schm_upd_cdt = defaultdict(dict)

         self.text1.config(state='normal')
         self.text1.delete("1.0", tk.END)
         self.text1.insert(tk.END, self.regle_tree)
         self.text1.config(state='disabled')

         self.label2.grid(row=1, column=2, pady=(15, 0), padx=(50, 0))
         self.text2.grid(row=1, column=3, pady=(20, 0), padx=(25, 0))

         self.text2.config(state='normal')
         self.text2.delete("1.0", tk.END)
         self.text2.insert(tk.END, "1")
         self.text2.config(state='disabled')

         self.text4.insert(tk.END, "Contrôlé")
         self.text4.config(state='disabled')

         for line in self.dict_line_all[self.regle_tree].split('|'):
            fields = re.split(r'\s{2,}', line)
            if all(s in fields[0] for s in ( "00000",self.regle_tree)) != FALSE and all(s in fields[1] for s in ( "..ITER..")) == FALSE :
               if fields[1] in self.dict_data_var.keys():
                  self.dict_data_var[fields[1]] = self.dict_data_var[fields[1]] + fields[2][4:].rstrip('\n')
               else:
                  self.dict_data_var[fields[1]] = fields[2][4:].rstrip('\n')

            if all(s in fields[0] for s in ( "DEL",self.regle_tree)) != FALSE and all(s in fields[1] for s in ( "..ITER..")) == FALSE:
               self.dict_data_reg[fields[0]][fields[1]] = fields[2].rstrip('\n')
            if all(s in fields[0] for s in ( "RSC",self.regle_tree)) != FALSE :
               #Insertion des conditions de la règle de jeu
               if fields[0] in self.dict_data_cdt.keys():
                  self.dict_data_cdt[fields[0]] = self.dict_data_cdt[fields[0]] + fields[1] + '\n'
               else:
                  self.dict_data_cdt[fields[0]] = fields[1] + '\n'

               if all(s in fields[1] for s in ( "E1LC")) != FALSE :
                  #Me sert pour les lignes modifiées
                  self.serial_date = fields[0].split(self.regle_tree)[1][:7]

                  self.text5.config(state='normal')
                  self.text5.delete("1.0", tk.END)
                  self.text5.insert(tk.END, fields[0].split(self.regle_tree)[1][:1]+"0"+fields[0].split(self.regle_tree)[1][1:3] + "/" + fields[0].split(self.regle_tree)[1][3:5] + "/" + fields[0].split(self.regle_tree)[1][5:7])
                  self.text5.config(state='disabled')

            if all(s in fields[0] for s in ("RIN", self.regle_tree)) != FALSE and all(s in fields[1] for s in ( "LC2991231")) != FALSE:
               self.text3.config(state='normal')
               self.text3.delete("1.0", tk.END)
               self.text3.insert(tk.END, fields[1].split("LC2991231")[1])
               self.text3.config(state='disabled')

         if evt == 'DICTIONARY' and self.dict_line_dictionary != {}:
            for line in self.dict_line_dictionary[self.regle_tree].split('|'):
               fields = re.split(r'\s{2,}', line)
               if all(s in fields[0] for s in ("DICT", self.regle_tree)) != FALSE:
                  if fields[0] in self.dict_schm_upd_cdt.keys():
                     self.dict_schm_upd_cdt[fields[0]] = self.dict_schm_upd_cdt[fields[0]] + fields[1] + '\n'
                  else:
                     self.dict_schm_upd_cdt[fields[0]] = fields[1] + '\n'


         for key,value in self.dict_data_var.items() :
           self.treev.insert("", 'end', text="L2", values=(key, value))

         """for key,value in self.dict_data_reg.items() :
            print(value['SEN'])"""

         i=1

         for key,value in self.dict_data_cdt.items() :
            string_schm = self.dict_schm_upd_cdt['DICT'+self.regle_tree+str(i-1)] if self.dict_schm_upd_cdt['DICT'+self.regle_tree+str(i-1)] != {} else "Schéma " + str(i)
            if re.match("C1LC",value) :
               cdt_schm = value.split('\n')
               self.treev_2.insert("", 'end', text="L2", values=(i, string_schm, cdt_schm[0], cdt_schm[1]))

            if re.match("E1LC",value):
               schm = value.split('\n')
               self.treev_2.insert("", 'end', text="L2", values=(i, string_schm, "" , schm[0]))

            i += 1

   def show(self,evt):
      curItem = self.treev_2.focus()
      num = self.treev_2.item(curItem)['values'][0]
      schm = self.treev_2.item(curItem)['values'][3]
      cdt = self.treev_2.item(curItem)['values'][2]
      line = str(schm).split('00')[0][4:]
      regle = self.regle_tree

      n=2
      list_reg_num = [line[i:i + n] for i in range(0, len(line), n)]
         #print(re.search(cdt,line))
      window = tk.Toplevel()
      TAB = MULTITABS(window,num,self.dict_data_reg,list_reg_num,cdt,regle)



      """
      w = evt.widget
      index = int(w.curselection()[0])
      value = w.get(index)
      print('You selected item %d: "%s"' % (index, value))
      root=tk.Tk()
      TABS=MULTITABS(root)
      root.mainloop()
      """